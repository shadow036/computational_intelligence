from random import choice
import random
import logging
from math import inf

"""
NOTATION:
-> candidate solution: [L0, L1, ..., Lm] where L# is a list of numbers waiting to be evaluated
-> evaluated solution: candidate solution after being evaluated (can be optimal or not, complete or not)
-> incomplete solution: evaluated solution with missing numbers (and thus not optimal as well)
-> complete solution: evaluated solution containing all numbers at least once (not necessarily the optimal one)
-> optimal solution: complete evaluated solution ideally having the highest fitness of all 
    (even though we cannot be sure since we have a limited number of generations)
-> offspring: candidate solution generated by mixing characteristics of two evaluated solutions
-> parent: evaluated solution
"""

N = 10
INVERSE_MUTATION_RATE = 20

def problem(N, seed=None):
    random.seed(seed)
    return [
        list(set(random.randint(0, N - 1) for n in range(random.randint(N // 5, N // 2))))
        for n in range(random.randint(N, N * 5))
    ]
"""
in order to have more variety I have chosen to apply 3 different mutations:
    0) remove a sublist if there is more than 1 sublist (5% chance)
    1) substitute a sublist (10% chance)
    2) add a sublist (5% chance)
"""
#def plus_strategy():
    
#def comma_strategy():
    
def selection(e_solutions, mu):
    return sorted(e_solutions, key=lambda t: t[1], reverse=True)[:mu]
    
def mutation(e_solutions, input_):
    c_solutions = [e_solutions[_][0] for _ in range(len(e_solutions))]
    for index in range(len(e_solutions)):
        if type(c_solutions[index][0]) is int:
            m = choice(range(INVERSE_MUTATION_RATE))
            if m in [1, 2]: # switch
                c_solutions[index] = input_[choice(range(len(input_)))]
            elif m == 3:    # add
                c_solutions[index] = [c_solutions[index], input_[choice(range(len(input_)))]]
        else:
            for index2 in range(len(c_solutions[index])):
                m = choice(range(INVERSE_MUTATION_RATE))
                if m == 0:  # remove
                    del c_solutions[index][index2]
                elif m in [1, 2]: # switch
                    c_solutions[index][index2] = input_[choice(range(len(input_)))]
                elif m == 3:    # add
                    c_solutions[index].append(input_[choice(range(len(input_)))])
    return c_solutions
        

def evaluate(c_solutions):
    e_solutions = c_solutions.copy()    # in order to make clear the difference between candidate and evaluated solutions
    for index in range(len(e_solutions)):
        counters = [0 for _ in range(N)]
        if type(e_solutions[index][0]) is int:
            counters = [counters[_]+1 if _ in e_solutions[index] else counters[_] for _ in range(N)]
        else:
            for e in e_solutions[index]:
                counters = [counters[_]+1 if _ in e else counters[_] for _ in range(N)]
        
        partial_fitness = sum([1 - counters[_] if counters[_] > 1 else counters[_] for _ in range(N)])
        offset = (-inf if counters.count(0) > 0 else 0)
        e_solutions[index] = (e_solutions[index], partial_fitness + offset)
        """
        OFFSET EXPLANATION
        if the candidate solution doesn't contain all required numbers it is not acceptable;
        it is better to have a complete solution with partial_fitness < N - 1
        with respect of having an incomplete solution with partial_fitness N - 1 
        (see "example A" at the end of the file for an example);
        we can picture the counters.count(0) as being an offset equal to -infinity if > 0 added 
        to the partial_fitness value described below
        
        """
        
        """
        PARTIAL FITNESS EXPLANATION
        for each element 'i' of the counters list:
            -> if it contains 1 (=> 1 occurrence of number 'i' in the candidate solution) 
                => fitness = fitness + 1;
            -> if it contains 0 (=> no occurrences of number 'i' in the candidate solution) 
                => fitness = fitness + 0;
            -> if it contains j > 1 (=> more than 1 occurences of number 'i' in the candidate solution) 
                => fitness = fitness - number of occurences above 1
        """
    return e_solutions

if __name__ == '__main__':
    input_ = problem(N, seed=42)
    mu = len(input_)
    print('Strategy :\nmu + lambda: type "+ lambda" \nmu, lambda: type ", lambda"')
    choice_ = input()
    stragegy = choice_[0]
    lambda_ = int(choice_.split(' ')[1])
    e_solutions = evaluate(input_.copy()) # list => (list, fitness)
    for i in range(10):
        c_solutions = mutation(e_solutions, input_) # (list, fitness) => list
        e_solutions = evaluate(c_solutions) # list => (list, fitness)
        e_solutions = selection(e_solutions, mu)    # (list, fitness) => (list, fitness)
"""
example A
example with N=5: 
    a) [[0, 1], [0, 2], [0, 3], [0, 4]]: partial_fitness 1 (4 for the 4 exact matches and - 3 for the 4 occurrences of 0)
    b) [[0, 1, 2, 3]]: partial fitness 4 (4 for the 4 exact matches and 0 for the missing number)
"""