# NOTATION:
-> candidate solution: [L0, L1, ..., Lm] where L# is a list of numbers waiting to be evaluated
-> evaluated solution: candidate solution after being evaluated (can be optimal or not, complete or not)
-> incomplete solution: evaluated solution with missing numbers (and thus not optimal as well)
-> complete solution: evaluated solution containing all numbers at least once (not necessarily the optimal one)
-> optimal solution: complete evaluated solution ideally having the highest fitness of all 
    (even though we cannot be sure since we have a limited number of generations)
-> offspring: candidate solution generated by mixing characteristics of two evaluated solutions
-> parent: evaluated solution

in order to have more variety I have chosen to apply 3 different mutations:
    0) remove a sublist if there is more than 1 sublist (5% chance)
    1) substitute a sublist (10% chance)
    2) add a sublist (5% chance)
    
# OFFSET EXPLANATION (line )
if the candidate solution doesn't contain all required numbers it is not acceptable;
it is better to have a complete solution with partial_fitness < N - 1
with respect of having an incomplete solution with partial_fitness N - 1 
(see "example A" at the end of the file for an example);
we can picture the counters.count(0) as being an offset equal to -infinity if > 0 added 
to the partial_fitness value described below

# PARTIAL FITNESS EXPLANATION (line )
for each element 'i' of the counters list:
    -> if it contains 1 (=> 1 occurrence of number 'i' in the candidate solution) 
        => fitness = fitness + 1;
    -> if it contains 0 (=> no occurrences of number 'i' in the candidate solution) 
        => fitness = fitness + 0;
    -> if it contains j > 1 (=> more than 1 occurences of number 'i' in the candidate solution) 
        => fitness = fitness - number of occurences above 1
